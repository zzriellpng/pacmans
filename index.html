<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Game Pac-Man</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }
        
        .score-board {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #ffd700;
            margin-bottom: 20px;
        }
        
        .score, .lives {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            background: #000;
            border: 4px solid #ffd700;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 300px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(145deg, #2a2a4a, #1a1a2e);
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
        }
        
        .up-btn {
            grid-column: 2;
            grid-row: 1;
        }
        
        .left-btn {
            grid-column: 1;
            grid-row: 2;
        }
        
        .right-btn {
            grid-column: 3;
            grid-row: 2;
        }
        
        .down-btn {
            grid-column: 2;
            grid-row: 3;
        }
        
        .action-buttons {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .action-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .start-btn {
            background: linear-gradient(145deg, #00b894, #00a382);
            color: white;
        }
        
        .reset-btn {
            background: linear-gradient(145deg, #ff7675, #e66767);
            color: white;
        }
        
        .action-btn:active {
            transform: scale(0.95);
        }
        
        .instructions {
            text-align: center;
            margin-top: 20px;
            font-size: 0.9rem;
            color: #b2bec3;
            max-width: 400px;
        }
        
        @media (max-width: 480px) {
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 1.3rem;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .score, .lives {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">PAC-MAN</h1>
        <div class="score-board">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="lives">Lives: <span id="lives">3</span></div>
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="game-canvas"></canvas>
    </div>
    
    <div class="controls">
        <button class="control-btn up-btn" id="up">↑</button>
        <button class="control-btn left-btn" id="left">←</button>
        <button class="control-btn right-btn" id="right">→</button>
        <button class="control-btn down-btn" id="down">↓</button>
    </div>
    
    <div class="action-buttons">
        <button class="action-btn start-btn" id="start">Start Game</button>
        <button class="action-btn reset-btn" id="reset">Reset</button>
    </div>
    
    <div class="instructions">
        <p>Makan semua titik untuk menang! Hindari hantu!</p>
        <p>Gunakan tombol panah untuk bergerak</p>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        
        // Setup canvas
        function setupCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        // Game variables
        const CELL_SIZE = 20;
        const PACMAN_SPEED = 2;
        const GHOST_SPEED = 1.5;
        
        let grid = [];
        let pacman = {
            x: 1,
            y: 1,
            direction: 'right',
            mouthOpen: true,
            mouthAngle: 0.2
        };
        
        let ghosts = [];
        let dots = [];
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let animationId = null;
        
        // Initialize game
        function initGame() {
            setupCanvas();
            createGrid();
            createDots();
            createGhosts();
            resetPacman();
            drawGame();
        }
        
        // Create game grid
        function createGrid() {
            const cols = Math.floor(canvas.width / CELL_SIZE);
            const rows = Math.floor(canvas.height / CELL_SIZE);
            
            grid = [];
            for (let y = 0; y < rows; y++) {
                grid[y] = [];
                for (let x = 0; x < cols; x++) {
                    // Create walls around the edges and some internal walls
                    if (x === 0 || y === 0 || x === cols - 1 || y === rows - 1 || 
                        (x % 4 === 0 && y % 3 === 0 && x !== 0 && y !== 0 && x !== cols - 1 && y !== rows - 1)) {
                        grid[y][x] = 1; // Wall
                    } else {
                        grid[y][x] = 0; // Empty space
                    }
                }
            }
        }
        
        // Create dots
        function createDots() {
            dots = [];
            for (let y = 1; y < grid.length - 1; y++) {
                for (let x = 1; x < grid[y].length - 1; x++) {
                    if (grid[y][x] === 0 && Math.random() > 0.3) {
                        dots.push({ x, y });
                    }
                }
            }
        }
        
        // Create ghosts
        function createGhosts() {
            ghosts = [];
            const ghostColors = ['#ff0000', '#00ffff', '#ff00ff', '#ffff00'];
            
            for (let i = 0; i < 4; i++) {
                ghosts.push({
                    x: Math.floor(grid[0].length / 2) + i * 2,
                    y: Math.floor(grid.length / 2),
                    color: ghostColors[i],
                    direction: ['up', 'down', 'left', 'right'][i],
                    speed: GHOST_SPEED
                });
            }
        }
        
        // Reset pacman position
        function resetPacman() {
            pacman.x = 1;
            pacman.y = 1;
            pacman.direction = 'right';
        }
        
        // Draw game
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw walls
            ctx.fillStyle = '#2244aa';
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    if (grid[y][x] === 1) {
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            // Draw dots
            ctx.fillStyle = '#ffffff';
            dots.forEach(dot => {
                ctx.beginPath();
                ctx.arc(
                    dot.x * CELL_SIZE + CELL_SIZE / 2,
                    dot.y * CELL_SIZE + CELL_SIZE / 2,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            });
            
            // Draw pacman
            drawPacman();
            
            // Draw ghosts
            ghosts.forEach(ghost => {
                drawGhost(ghost);
            });
        }
        
        // Draw pacman
        function drawPacman() {
            ctx.save();
            ctx.translate(
                pacman.x * CELL_SIZE + CELL_SIZE / 2,
                pacman.y * CELL_SIZE + CELL_SIZE / 2
            );
            
            // Rotate based on direction
            switch (pacman.direction) {
                case 'right': ctx.rotate(0); break;
                case 'down': ctx.rotate(Math.PI / 2); break;
                case 'left': ctx.rotate(Math.PI); break;
                case 'up': ctx.rotate(-Math.PI / 2); break;
            }
            
            // Draw pacman body
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            
            if (pacman.mouthOpen) {
                ctx.arc(0, 0, CELL_SIZE / 2 - 2, pacman.mouthAngle, Math.PI * 2 - pacman.mouthAngle);
            } else {
                ctx.arc(0, 0, CELL_SIZE / 2 - 2, 0, Math.PI * 2);
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        // Draw ghost
        function drawGhost(ghost) {
            const x = ghost.x * CELL_SIZE;
            const y = ghost.y * CELL_SIZE;
            
            ctx.fillStyle = ghost.color;
            
            // Draw ghost body (semi-circle top + rectangle bottom)
            ctx.beginPath();
            ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, CELL_SIZE / 2 - 2, Math.PI, 0, false);
            ctx.lineTo(x + CELL_SIZE, y + CELL_SIZE);
            ctx.lineTo(x, y + CELL_SIZE);
            ctx.closePath();
            ctx.fill();
            
            // Draw eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x + CELL_SIZE / 3, y + CELL_SIZE / 3, 3, 0, Math.PI * 2);
            ctx.arc(x + 2 * CELL_SIZE / 3, y + CELL_SIZE / 3, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + CELL_SIZE / 3, y + CELL_SIZE / 3, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 2 * CELL_SIZE / 3, y + CELL_SIZE / 3, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Update game state
        function updateGame() {
            if (!gameRunning) return;
            
            // Animate pacman mouth
            pacman.mouthOpen = !pacman.mouthOpen;
            
            // Move pacman
            movePacman();
            
            // Move ghosts
            moveGhosts();
            
            // Check dot collection
            checkDotCollection();
            
            // Check ghost collision
            checkGhostCollision();
            
            // Check win condition
            checkWinCondition();
            
            // Draw updated game
            drawGame();
            
            // Continue animation
            animationId = requestAnimationFrame(updateGame);
        }
        
        // Move pacman
        function movePacman() {
            let newX = pacman.x;
            let newY = pacman.y;
            
            switch (pacman.direction) {
                case 'right': newX += PACMAN_SPEED / CELL_SIZE; break;
                case 'left': newX -= PACMAN_SPEED / CELL_SIZE; break;
                case 'down': newY += PACMAN_SPEED / CELL_SIZE; break;
                case 'up': newY -= PACMAN_SPEED / CELL_SIZE; break;
            }
            
            // Check wall collision
            const gridX = Math.floor(newX);
            const gridY = Math.floor(newY);
            
            if (gridY >= 0 && gridY < grid.length && 
                gridX >= 0 && gridX < grid[0].length && 
                grid[gridY][gridX] !== 1) {
                pacman.x = newX;
                pacman.y = newY;
            }
        }
        
        // Move ghosts
        function moveGhosts() {
            ghosts.forEach(ghost => {
                // Simple AI: change direction randomly or when hitting wall
                if (Math.random() < 0.05) {
                    const directions = ['up', 'down', 'left', 'right'];
                    ghost.direction = directions[Math.floor(Math.random() * directions.length)];
                }
                
                let newX = ghost.x;
                let newY = ghost.y;
                
                switch (ghost.direction) {
                    case 'right': newX += ghost.speed / CELL_SIZE; break;
                    case 'left': newX -= ghost.speed / CELL_SIZE; break;
                    case 'down': newY += ghost.speed / CELL_SIZE; break;
                    case 'up': newY -= ghost.speed / CELL_SIZE; break;
                }
                
                // Check wall collision and bounds
                const gridX = Math.floor(newX);
                const gridY = Math.floor(newY);
                
                if (gridY >= 0 && gridY < grid.length && 
                    gridX >= 0 && gridX < grid[0].length && 
                    grid[gridY][gridX] !== 1) {
                    ghost.x = newX;
                    ghost.y = newY;
                } else {
                    // Change direction if hitting wall
                    const directions = ['up', 'down', 'left', 'right'];
                    ghost.direction = directions[Math.floor(Math.random() * directions.length)];
                }
            });
        }
        
        // Check dot collection
        function checkDotCollection() {
            for (let i = dots.length - 1; i >= 0; i--) {
                const dot = dots[i];
                const distance = Math.sqrt(
                    Math.pow(pacman.x - dot.x, 2) + 
                    Math.pow(pacman.y - dot.y, 2)
                );
                
                if (distance < 0.5) {
                    dots.splice(i, 1);
                    score += 10;
                    scoreDisplay.textContent = score;
                }
            }
        }
        
        // Check ghost collision
        function checkGhostCollision() {
            ghosts.forEach(ghost => {
                const distance = Math.sqrt(
                    Math.pow(pacman.x - ghost.x, 2) + 
                    Math.pow(pacman.y - ghost.y, 2)
                );
                
                if (distance < 0.7) {
                    lives--;
                    livesDisplay.textContent = lives;
                    
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        resetPacman();
                    }
                }
            });
        }
        
        // Check win condition
        function checkWinCondition() {
            if (dots.length === 0) {
                gameRunning = false;
                cancelAnimationFrame(animationId);
                alert('Selamat! Kamu menang! Score: ' + score);
            }
        }
        
        // Game over
        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            alert('Game Over! Score akhir: ' + score);
        }
        
        // Start game
        function startGame() {
            if (!gameRunning) {
                gameRunning = true;
                score = 0;
                lives = 3;
                scoreDisplay.textContent = score;
                livesDisplay.textContent = lives;
                createDots();
                resetPacman();
                createGhosts();
                updateGame();
            }
        }
        
        // Reset game
        function resetGame() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            score = 0;
            lives = 3;
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            createDots();
            resetPacman();
            createGhosts();
            drawGame();
        }
        
        // Event listeners
        document.getElementById('up').addEventListener('click', () => {
            pacman.direction = 'up';
        });
        
        document.getElementById('down').addEventListener('click', () => {
            pacman.direction = 'down';
        });
        
        document.getElementById('left').addEventListener('click', () => {
            pacman.direction = 'left';
        });
        
        document.getElementById('right').addEventListener('click', () => {
            pacman.direction = 'right';
        });
        
        document.getElementById('start').addEventListener('click', startGame);
        document.getElementById('reset').addEventListener('click', resetGame);
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': pacman.direction = 'up'; break;
                case 'ArrowDown': pacman.direction = 'down'; break;
                case 'ArrowLeft': pacman.direction = 'left'; break;
                case 'ArrowRight': pacman.direction = 'right'; break;
            }
        });
        
        // Touch swipe controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Horizontal swipe
                if (diffX > 0) {
                    pacman.direction = 'right';
                } else {
                    pacman.direction = 'left';
                }
            } else {
                // Vertical swipe
                if (diffY > 0) {
                    pacman.direction = 'down';
                } else {
                    pacman.direction = 'up';
                }
            }
            
            e.preventDefault();
        });
        
        // Initialize game on load
        window.addEventListener('load', initGame);
        window.addEventListener('resize', () => {
            setupCanvas();
            drawGame();
        });
    </script>
</body>
</html>

